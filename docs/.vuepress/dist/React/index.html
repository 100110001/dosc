<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React | VuePress</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="VuePress template, theme, and plugin Demo. The purpose is that users can directly clone this repository as a startup project for initializing a VuePress website, and then add custom configurations and functions based on this project.">
    
    <link rel="preload" href="/vuepress/assets/css/0.styles.949ab0ff.css" as="style"><link rel="preload" href="/vuepress/assets/js/app.057f928e.js" as="script"><link rel="preload" href="/vuepress/assets/js/3.7d3f161f.js" as="script"><link rel="preload" href="/vuepress/assets/js/13.53aa0f3b.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/10.0362c666.js"><link rel="prefetch" href="/vuepress/assets/js/11.6a60214b.js"><link rel="prefetch" href="/vuepress/assets/js/12.a02c671a.js"><link rel="prefetch" href="/vuepress/assets/js/14.18ffdc25.js"><link rel="prefetch" href="/vuepress/assets/js/15.2c96ce6c.js"><link rel="prefetch" href="/vuepress/assets/js/16.493ded96.js"><link rel="prefetch" href="/vuepress/assets/js/17.55f7127c.js"><link rel="prefetch" href="/vuepress/assets/js/18.faa4fbeb.js"><link rel="prefetch" href="/vuepress/assets/js/19.913de091.js"><link rel="prefetch" href="/vuepress/assets/js/20.cb5c944b.js"><link rel="prefetch" href="/vuepress/assets/js/4.38f628fa.js"><link rel="prefetch" href="/vuepress/assets/js/5.0261035c.js"><link rel="prefetch" href="/vuepress/assets/js/6.0b084344.js"><link rel="prefetch" href="/vuepress/assets/js/7.4545af3c.js"><link rel="prefetch" href="/vuepress/assets/js/8.49aaa386.js"><link rel="prefetch" href="/vuepress/assets/js/9.f9c402da.js"><link rel="prefetch" href="/vuepress/assets/js/vendors~docsearch.21b1897d.js">
    <link rel="stylesheet" href="/vuepress/assets/css/0.styles.949ab0ff.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress/" class="home-link router-link-active"><!----> <span class="site-name">VuePress</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vuepress/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="/vuepress/Web/" class="nav-link">
  Web
</a></div><div class="nav-item"><a href="/vuepress/JavaScript/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">Store</span> <span class="arrow down"></span></button> <button type="button" aria-label="JavaScript" class="mobile-dropdown-title"><span class="title">Store</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress/React/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  React
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vuepress/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="/vuepress/Web/" class="nav-link">
  Web
</a></div><div class="nav-item"><a href="/vuepress/JavaScript/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">Store</span> <span class="arrow down"></span></button> <button type="button" aria-label="JavaScript" class="mobile-dropdown-title"><span class="title">Store</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress/React/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  React
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/vuepress/React/" aria-current="page" class="active sidebar-link">React</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress/React/#state" class="sidebar-link">State</a></li><li class="sidebar-sub-header"><a href="/vuepress/React/#生命周期" class="sidebar-link">生命周期</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress/React/#初始化阶段" class="sidebar-link">初始化阶段</a></li><li class="sidebar-sub-header"><a href="/vuepress/React/#运行中阶段" class="sidebar-link">运行中阶段</a></li><li class="sidebar-sub-header"><a href="/vuepress/React/#销毁阶段" class="sidebar-link">销毁阶段</a></li><li class="sidebar-sub-header"><a href="/vuepress/React/#老生命周期存在的问题" class="sidebar-link">老生命周期存在的问题</a></li><li class="sidebar-sub-header"><a href="/vuepress/React/#新生命周期的替代" class="sidebar-link">新生命周期的替代</a></li></ul></li><li class="sidebar-sub-header"><a href="/vuepress/React/#组件通讯" class="sidebar-link">组件通讯</a></li><li class="sidebar-sub-header"><a href="/vuepress/React/#context" class="sidebar-link">Context</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress/React/#使用问题" class="sidebar-link">使用问题</a></li><li class="sidebar-sub-header"><a href="/vuepress/React/#api" class="sidebar-link">API</a></li></ul></li><li class="sidebar-sub-header"><a href="/vuepress/React/#react-fc" class="sidebar-link">React.FC</a></li><li class="sidebar-sub-header"><a href="/vuepress/React/#错误边界" class="sidebar-link">错误边界</a></li><li class="sidebar-sub-header"><a href="/vuepress/React/#react-component" class="sidebar-link">React.Component</a></li><li class="sidebar-sub-header"><a href="/vuepress/React/#生命周期-2" class="sidebar-link">生命周期</a></li><li class="sidebar-sub-header"><a href="/vuepress/React/#render" class="sidebar-link">render()</a></li><li class="sidebar-sub-header"><a href="/vuepress/React/#创建-react-元素" class="sidebar-link">创建 React 元素</a></li><li class="sidebar-sub-header"><a href="/vuepress/React/#转换元素" class="sidebar-link">转换元素</a></li><li class="sidebar-sub-header"><a href="/vuepress/React/#fragments" class="sidebar-link">Fragments</a></li><li class="sidebar-sub-header"><a href="/vuepress/React/#refs" class="sidebar-link">Refs</a></li><li class="sidebar-sub-header"><a href="/vuepress/React/#suspense" class="sidebar-link">Suspense</a></li><li class="sidebar-sub-header"><a href="/vuepress/React/#hook" class="sidebar-link">Hook</a></li></ul></li><li><a href="/vuepress/React/method.html" class="sidebar-link">/React/method.html</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react"><a href="#react" class="header-anchor">#</a> React</h1> <h2 id="state"><a href="#state" class="header-anchor">#</a> State</h2> <ul><li><p>state 为局部的或是封装</p></li> <li><p>使用 setState 更新参数</p></li> <li><p>因为 props 和 state 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。要解决这个问题，可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Correct</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
  counter<span class="token operator">:</span> state<span class="token punctuation">.</span>counter <span class="token operator">+</span> props<span class="token punctuation">.</span>increment<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>当你调用 setState() 的时候，React 会把你提供的对象合并到当前的 state （浅合并）</p></li></ul> <hr> <h2 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h2> <h3 id="初始化阶段"><a href="#初始化阶段" class="header-anchor">#</a> 初始化阶段</h3> <ul><li>componentWillMount:：render 之前最后一次修改状态的机会</li> <li>render： 只能访问 props 和 state，不允许修改状态和 DOM 输出</li> <li>componentDidMount：成功 render 并渲染完成真是 DOM 之后触发，可以修改 DOM</li></ul> <h3 id="运行中阶段"><a href="#运行中阶段" class="header-anchor">#</a> 运行中阶段</h3> <ul><li>componentWillReceiveProps：父组件修改属性出发</li> <li>shouldComponentUpdate：返回 false 会阻止 render 调用</li> <li>componentWillUpdate： 不能修改属性和状态</li> <li>render ： 只能访问 props 和 state，不允许修改状态和 DOM 输出</li> <li>componentDidUpdate：可以修改 DOM</li></ul> <h3 id="销毁阶段"><a href="#销毁阶段" class="header-anchor">#</a> 销毁阶段</h3> <ul><li>componentWillUnmount：在删除组件之前进行清理操作，比如计时器和事件监听</li></ul> <h3 id="老生命周期存在的问题"><a href="#老生命周期存在的问题" class="header-anchor">#</a> 老生命周期存在的问题</h3> <ul><li>componentWillMount，在 SSR 中这个方法会被多次调用，重复触发，同时如果其中绑定了事件，将无法解绑，导致内存泄漏</li> <li>componentWillReceiveProps，外部组件多次频繁更新，传入不同 props，导致不必要请求</li> <li>componentWillUpdate，更新前记录 DOM 状态，可能会做一些处理，与 componentDidUpdate 相隔时间如果过长，会导致状态不可信</li></ul> <h3 id="新生命周期的替代"><a href="#新生命周期的替代" class="header-anchor">#</a> 新生命周期的替代</h3> <ul><li>getDerivedStateFromProps，第一次的 初始化组件以及后续的更新过程中（包括自身状态更新以及父传子），返回一个对象作为新的 state，返回 null 则说明不需要在这里更新 state</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token comment">//老的生命周期的写法</span>
    <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>value <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> current<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>value <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">componentWillReceiveProps</span><span class="token punctuation">(</span><span class="token parameter">nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>nextProps<span class="token punctuation">.</span>value <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> current<span class="token operator">:</span> nextProps<span class="token punctuation">.</span>value <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 新的生命周期写法</span>
   	<span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span><span class="token parameter">nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>nextProps<span class="token punctuation">.</span>value <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span> current<span class="token operator">:</span> nextProps<span class="token punctuation">.</span>value <span class="token punctuation">}</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><ul><li>getSnapshotBeforeUpdate，取代了 componentWillupdate，触发时间为 update 发生的时候，在 render 之后 DOM 渲染之前返回一个值，作为 componentDidUpdate 的第三个参数</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">getSnapshotBeforeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>refs<span class="token punctuation">.</span>wrapper<span class="token punctuation">.</span>scrollHeight <span class="token punctuation">}</span>
</code></pre></div><hr> <h2 id="组件通讯"><a href="#组件通讯" class="header-anchor">#</a> 组件通讯</h2> <ul><li>父子组件通讯方式
<ul><li>Props</li> <li>Instance Methods</li> <li>Callback Functions</li> <li>Event Bubbling</li> <li>Parent Component</li></ul></li></ul> <hr> <h2 id="context"><a href="#context" class="header-anchor">#</a> Context</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。</span>
<span class="token comment">// 为当前的 theme 创建一个 context（“light”为默认值）。</span>
<span class="token keyword">const</span> ThemeContext <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span><span class="token string">&quot;light&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用一个 Provider 来将当前的 theme 传递给以下的组件树。</span>
    <span class="token comment">// 无论多深，任何组件都能读取这个值。</span>
    <span class="token comment">// 在这个例子中，我们将 “dark” 作为当前的值传递下去。</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>ThemeContext<span class="token punctuation">.</span>Provider value<span class="token operator">=</span><span class="token string">&quot;dark&quot;</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>Toolbar <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>ThemeContext<span class="token punctuation">.</span>Provider<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 中间的组件再也不必指明往下传递 theme 了。</span>
<span class="token keyword">function</span> <span class="token function">Toolbar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>ThemedButton <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">ThemedButton</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token comment">// 指定 contextType 读取当前的 theme context。</span>
  <span class="token comment">// React 会往上找到最近的 theme Provider，然后使用它的值。</span>
  <span class="token comment">// 在这个例子中，当前的 theme 值为 “dark”。</span>
  <span class="token keyword">static</span> contextType <span class="token operator">=</span> ThemeContext<span class="token punctuation">;</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>Button theme<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="使用问题"><a href="#使用问题" class="header-anchor">#</a> 使用问题</h3> <p><strong>如果你只是想避免层层传递一些属性，<a href="https://zh-hans.reactjs.org/docs/composition-vs-inheritance.html" target="_blank" rel="noopener noreferrer">组件组合（component composition）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>有时候是一个比 context 更好的解决方案。</strong></p> <h3 id="api"><a href="#api" class="header-anchor">#</a> API</h3> <ul><li><code>React.createContext</code></li> <li><code>Context.Provider</code></li> <li><code>Class.contextType</code></li> <li><code>Context.Consumer</code></li> <li><code>Context.displayName</code></li></ul> <hr> <h2 id="react-fc"><a href="#react-fc" class="header-anchor">#</a> React.FC</h2> <ol><li><code>React.FC</code>是函数式组件，是在<a href="https://so.csdn.net/so/search?q=TypeScript&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">TypeScript<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>使用的一个泛型，FC 就是<code>FunctionComponent</code>的缩写，事实上<code>React.FC</code>可以写成<code>React.FunctionComponent</code></li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> App<span class="token operator">:</span> React<span class="token punctuation">.</span>FunctionComponent<span class="token operator">&lt;</span><span class="token punctuation">{</span> message<span class="token operator">:</span> string <span class="token punctuation">}</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> message <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span>message<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ol start="2"><li>React.FC 包含了 PropsWithChildren 的泛型，不用显式的声明 props.children 的类型。React.FC&lt;&gt; 对于返回类型是显式的，而普通函数版本是隐式的（否则需要附加注释）。</li> <li>React.FC 提供了类型检查和自动完成的静态属性：displayName，propTypes 和 defaultProps（注意：defaultProps 与 React.FC 结合使用会存在一些问题）。</li> <li>我们使用 React.FC 来写 React 组件的时候，是不能用 setState 的，取而代之的是 useState()、useEffect 等 Hook API。</li></ol> <hr> <h2 id="错误边界"><a href="#错误边界" class="header-anchor">#</a> 错误边界</h2> <p>​ <strong>可以捕获发生在其子组件树任何位置的 JavaScript 错误，并打印这些错误，同时展示降级 UI</strong>,而并不会渲染那些发生崩溃的子组件树。错误边界可以捕获发生在整个子组件树的渲染期间、生命周期方法以及构造函数中的错误。</p> <blockquote><p>注意</p> <p>错误边界<strong>无法</strong>捕获以下场景中产生的错误：</p> <ul><li>事件处理（<a href="https://zh-hans.reactjs.org/docs/error-boundaries.html#how-about-event-handlers" target="_blank" rel="noopener noreferrer">了解更多<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>）</li> <li>异步代码（例如 <code>setTimeout</code> 或 <code>requestAnimationFrame</code> 回调函数）</li> <li>服务端渲染</li> <li>它自身抛出来的错误（并非它的子组件）</li></ul></blockquote> <p>注意<strong>错误边界仅可以捕获其子组件的错误</strong>，它无法捕获其自身的错误。如果一个错误边界无法渲染错误信息，则错误会冒泡至最近的上层错误边界，这也类似于 JavaScript 中 <code>catch {}</code> 的工作机制。</p> <h1 id="组件"><a href="#组件" class="header-anchor">#</a> 组件</h1> <p>使用 React 组件可以将 UI 拆分为独立且复用的代码片段，每部分都可独立维护。你可以通过子类 React.Component 或 React.PureComponent 来定义 React 组件。</p> <ul><li>React.Component</li> <li>React.PureComponent</li></ul> <p>如果你不使用 ES6 的 class，则可以使用 create-react-class 模块来替代。请参阅不使用 ES6 以获取更多详细信息。</p> <p>React 组件也可以被定义为可被包装的函数：</p> <ul><li>React.memo</li></ul> <h2 id="react-component"><a href="#react-component" class="header-anchor">#</a> React.Component</h2> <p>在 React 组件中，代码重用的主要方式是组合而不是继承。</p> <h2 id="生命周期-2"><a href="#生命周期-2" class="header-anchor">#</a> 生命周期</h2> <p><img src="C:%5CUsers%5Cll%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220321165406807.png" alt="image-20220321165406807"></p> <p><strong><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener noreferrer">生命周期图谱<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></strong></p> <h2 id="render"><a href="#render" class="header-anchor">#</a> render()</h2> <p>render() 方法是 class 组件中唯一必须实现的方法。</p> <p>当 render 被调用时，它会检查 this.props 和 this.state 的变化并返回以下类型之一：</p> <ul><li>React 元素。通常通过 JSX 创建。例如，<code>&lt;div /&gt;</code> 会被 React 渲染为 DOM 节点，<code>&lt;MyComponent /&gt;</code> 会被 React 渲染为自定义组件，无论是 <code>&lt;div /&gt;</code> 还是 <code>&lt;MyComponent /&gt;</code> 均为 React 元素。</li> <li>数组或 fragments。 使得 render 方法可以返回多个元素。欲了解更多详细信息，请参阅 fragments 文档。</li> <li>Portals。可以渲染子节点到不同的 DOM 子树中。欲了解更多详细信息，请参阅有关 portals 的文档</li> <li>字符串或数值类型。它们在 DOM 中会被渲染为文本节点</li> <li>布尔类型或 null。什么都不渲染。（主要用于支持返回 test &amp;&amp; <code>&lt;Child /&gt;</code> 的模式，其中 test 为布尔类型。)</li></ul> <p>render() 函数应该为纯函数，这意味着在不修改组件 state 的情况下，每次调用时都返回相同的结果，并且它不会直接与浏览器交互。</p> <p>如需与浏览器进行交互，请在 componentDidMount() 或其他生命周期方法中执行你的操作。保持 render() 为纯函数，可以使组件更容易思考。</p> <blockquote><p>注意</p> <p>如果 shouldComponentUpdate() 返回 false，则不会调用 render()。</p></blockquote> <hr> <hr> <hr> <h2 id="创建-react-元素"><a href="#创建-react-元素" class="header-anchor">#</a> 创建 React 元素</h2> <p>我们建议使用 JSX 来编写你的 UI 组件。每个 JSX 元素都是调用 React.createElement() 的语法糖。一般来说，如果你使用了 JSX，就不再需要调用以下方法。</p> <ul><li>createElement()</li> <li>createFactory()</li></ul> <p>请参阅不使用 JSX 以获取更多详细信息。</p> <h2 id="转换元素"><a href="#转换元素" class="header-anchor">#</a> 转换元素</h2> <p>React 提供了几个用于操作元素的 API：</p> <ul><li>cloneElement()</li> <li>isValidElement()</li> <li>React.Children</li></ul> <h2 id="fragments"><a href="#fragments" class="header-anchor">#</a> Fragments</h2> <p>React 还提供了用于减少不必要嵌套的组件。</p> <ul><li>React.Fragment</li></ul> <h2 id="refs"><a href="#refs" class="header-anchor">#</a> Refs</h2> <ul><li>React.createRef</li> <li>React.forwardRef</li></ul> <p>Ref 转发是一个可选特性，其允许某些组件接收 ref，并将其向下传递（换句话说，“转发”它）给子组件。</p> <h2 id="suspense"><a href="#suspense" class="header-anchor">#</a> Suspense</h2> <p>Suspense 使得组件可以“等待”某些操作结束后，再进行渲染。目前，Suspense 仅支持的使用场景是：通过 React.lazy 动态加载组件。它将在未来支持其它使用场景，如数据获取等。</p> <ul><li>React.lazy</li> <li>React.Suspense</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> LazyCom <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&quot;./lazy&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>React.lazy 目前只支持默认导出（default exports）。</li></ul> <h2 id="hook"><a href="#hook" class="header-anchor">#</a> Hook</h2> <p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。Hook 拥有专属文档章节和单独的 API 参考文档：</p> <ul><li>基础 Hook
<ul><li>useState</li> <li>useEffect</li> <li>useContext</li></ul></li> <li>额外的 Hook
<ul><li>useReducer</li> <li>useCallback</li> <li>useMemo</li> <li>useRef</li> <li>useImperativeHandle</li> <li>useLayoutEffect</li> <li>useDebugValue</li></ul></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">2022/7/1 18:57:42</span></div></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/vuepress/React/method.html">
        /React/method.html
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/vuepress/assets/js/app.057f928e.js" defer></script><script src="/vuepress/assets/js/3.7d3f161f.js" defer></script><script src="/vuepress/assets/js/13.53aa0f3b.js" defer></script>
  </body>
</html>
