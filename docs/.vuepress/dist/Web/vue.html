<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue | VuePress</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="VuePress template, theme, and plugin Demo. The purpose is that users can directly clone this repository as a startup project for initializing a VuePress website, and then add custom configurations and functions based on this project.">
    
    <link rel="preload" href="/vuepress/assets/css/0.styles.949ab0ff.css" as="style"><link rel="preload" href="/vuepress/assets/js/app.057f928e.js" as="script"><link rel="preload" href="/vuepress/assets/js/3.7d3f161f.js" as="script"><link rel="preload" href="/vuepress/assets/js/16.493ded96.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/10.0362c666.js"><link rel="prefetch" href="/vuepress/assets/js/11.6a60214b.js"><link rel="prefetch" href="/vuepress/assets/js/12.a02c671a.js"><link rel="prefetch" href="/vuepress/assets/js/13.53aa0f3b.js"><link rel="prefetch" href="/vuepress/assets/js/14.18ffdc25.js"><link rel="prefetch" href="/vuepress/assets/js/15.2c96ce6c.js"><link rel="prefetch" href="/vuepress/assets/js/17.55f7127c.js"><link rel="prefetch" href="/vuepress/assets/js/18.faa4fbeb.js"><link rel="prefetch" href="/vuepress/assets/js/19.913de091.js"><link rel="prefetch" href="/vuepress/assets/js/20.cb5c944b.js"><link rel="prefetch" href="/vuepress/assets/js/4.38f628fa.js"><link rel="prefetch" href="/vuepress/assets/js/5.0261035c.js"><link rel="prefetch" href="/vuepress/assets/js/6.0b084344.js"><link rel="prefetch" href="/vuepress/assets/js/7.4545af3c.js"><link rel="prefetch" href="/vuepress/assets/js/8.49aaa386.js"><link rel="prefetch" href="/vuepress/assets/js/9.f9c402da.js"><link rel="prefetch" href="/vuepress/assets/js/vendors~docsearch.21b1897d.js">
    <link rel="stylesheet" href="/vuepress/assets/css/0.styles.949ab0ff.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress/" class="home-link router-link-active"><!----> <span class="site-name">VuePress</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vuepress/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="/vuepress/Web/" class="nav-link router-link-active">
  Web
</a></div><div class="nav-item"><a href="/vuepress/JavaScript/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">Store</span> <span class="arrow down"></span></button> <button type="button" aria-label="JavaScript" class="mobile-dropdown-title"><span class="title">Store</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress/React/" class="nav-link">
  React
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vuepress/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="/vuepress/Web/" class="nav-link router-link-active">
  Web
</a></div><div class="nav-item"><a href="/vuepress/JavaScript/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">Store</span> <span class="arrow down"></span></button> <button type="button" aria-label="JavaScript" class="mobile-dropdown-title"><span class="title">Store</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress/React/" class="nav-link">
  React
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/vuepress/Web/" aria-current="page" class="sidebar-link">Web</a></li><li><a href="/vuepress/Web/code.html" class="sidebar-link">代码</a></li><li><a href="/vuepress/Web/vue.html" aria-current="page" class="active sidebar-link">Vue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress/Web/vue.html#虚拟dom" class="sidebar-link">虚拟DOM</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress/Web/vue.html#优缺点" class="sidebar-link">优缺点</a></li></ul></li><li class="sidebar-sub-header"><a href="/vuepress/Web/vue.html#diff算法" class="sidebar-link">diff算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress/Web/vue.html#vue2-x-vue3-x-react-中的-diff-有区别吗" class="sidebar-link">vue2.x，vue3.x，React 中的 diff 有区别吗？</a></li></ul></li><li class="sidebar-sub-header"><a href="/vuepress/Web/vue.html#nexttick" class="sidebar-link">nextTick</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress/Web/vue.html#event-loop" class="sidebar-link">Event Loop</a></li><li class="sidebar-sub-header"><a href="/vuepress/Web/vue.html#mutationobserver" class="sidebar-link">MutationObserver</a></li><li class="sidebar-sub-header"><a href="/vuepress/Web/vue.html#nexttick-实现原理" class="sidebar-link">nextTick 实现原理</a></li><li class="sidebar-sub-header"><a href="/vuepress/Web/vue.html#源码解读" class="sidebar-link">源码解读</a></li></ul></li><li class="sidebar-sub-header"><a href="/vuepress/Web/vue.html#组件设计" class="sidebar-link">组件设计</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue"><a href="#vue" class="header-anchor">#</a> Vue</h1> <h2 id="虚拟dom"><a href="#虚拟dom" class="header-anchor">#</a> 虚拟DOM</h2> <p>Virtual DOM是对DOM的抽象，本质上是JavaScript对象，这个对象就是更加轻量级的对DOM的描述.</p> <h3 id="优缺点"><a href="#优缺点" class="header-anchor">#</a> 优缺点</h3> <ul><li>减少DOM操作。DOM相对较慢，更因为频繁变动DOM会造成浏览器的回流或者重回，这些都是性能的杀手，因此我们需要这一层抽象，在patch过程中尽可能地一次性将差异更新到DOM中，这样保证了DOM不会出现性能很差的情况.</li> <li>无须手动操作DOM。一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提高开发效率.</li> <li>更好的跨平台。比如Node.js就没有DOM，如果想实现SSR(服务端渲染)，那么一个方式就是借助Virtual DOM，因为Virtual DOM本身是JavaScript对象。</li> <li>内存占用较高，因为需要模拟整个网页的真实 DOM。</li> <li>高性能应用场景存在难以优化的情况，类似像 Google Earth 一类的高性能前端应用在技术选型上往往不会选择 React。</li></ul> <h2 id="diff算法"><a href="#diff算法" class="header-anchor">#</a> diff算法</h2> <p>Diff算法是一种对比算法。对比两者是旧虚拟DOM和新虚拟DOM，对比出是哪个虚拟节点更改了，找出这个虚拟节点，并只更新这个虚拟节点所对应的真实节点，而不用更新其他数据没发生改变的节点，实现精准地更新真实DOM，进而提高效率。</p> <ul><li>使用虚拟DOM算法的损耗计算： 总损耗 = 虚拟DOM增删改+（与Diff算法效率有关）真实DOM差异增删改+（较少的节点）排版与重绘</li> <li>直接操作真实DOM的损耗计算： 总损耗 = 真实DOM完全增删改+（可能较多的节点）排版与重绘</li></ul> <h3 id="vue2-x-vue3-x-react-中的-diff-有区别吗"><a href="#vue2-x-vue3-x-react-中的-diff-有区别吗" class="header-anchor">#</a> vue2.x，vue3.x，React 中的 diff 有区别吗？</h3> <ul><li>vue2.x 的核心 diff 算法采用双端比较的算法，同时从新旧 children 的两端开始进行比较，借助 key 可以复用的节点。</li> <li>vue3.x 借鉴了一些别的算法 inferno(<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Finfernojs%2Finferno" target="_blank" rel="noopener noreferrer">github.com/infernojs/i…<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>) 解决：1、处理相同的前置和后置元素的预处理；2、一旦需要进行 DOM 移动，我们首先要做的就是找到 source 的最长递增子序列。</li></ul> <p>在创建 VNode 就确定类型，以及在 mount/patch 的过程中采用位运算来判断一个 VNode 的类型，在这个优化的基础上再配合 Diff 算法，性能得到提升。</p> <ul><li>react 通过 key 和 tag 来对节点进行取舍，可直接将复杂的比对拦截掉，然后降级成节点的移动和增删这样比较简单的操作。</li></ul> <p>对 oldFiber 和新的 ReactElement 节点的比对，将会生成新的 fiber 节点，同时标记上 effectTag，这些 fiber 会被连到 workInProgress 树中，作为新的 WIP 节点。树的结构因此被一点点地确定，而新的 workInProgress 节点也基本定型。在 diff 过后，workInProgress 节点的 beginWork 节点就完成了，接下来会进入 completeWork 阶段。</p> <h2 id="nexttick"><a href="#nexttick" class="header-anchor">#</a> nextTick</h2> <h3 id="event-loop"><a href="#event-loop" class="header-anchor">#</a> Event Loop</h3> <p>macro task宏任务和micro task微任务</p> <p>在浏览器环境下，macro task和micro task对应如下：</p> <ul><li>macro task宏任务：MessageChannel、postMessage、setImmediate和setTimeout。</li> <li>micro task微任务：Promise.then和MutationObsever。</li></ul> <h3 id="mutationobserver"><a href="#mutationobserver" class="header-anchor">#</a> MutationObserver</h3> <p>创建并返回一个新的 MutationObserver 实例，它会在指定的DOM发生变化时被调用。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">callback</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'text node data change'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MutationObserver</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span>
<span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">const</span> textNode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>
observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>textNode<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  characterData<span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">func</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  count<span class="token operator">++</span>
  textNode<span class="token punctuation">.</span>data <span class="token operator">=</span> count
<span class="token punctuation">}</span>
<span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// text node data change</span>
</code></pre></div><p>代码分析：</p> <ul><li>首先定义了callback回调函数和MutationObserver的实例对象，其中构造函数传递的参数是我们的callback。</li> <li>然后创建一个文本节点并传入文本节点的初始文本，接着调用MutationObserver实例的observe方法，传入我们创建的文本节点和一个config观察配置对象，其中characterData:true的意思是：我们要观察textNode节点的文本变动。config还有其他选项属性，你可以在MDN文档中查看到。</li> <li>接着，我们定义一个func函数，这个函数主要做的事情就是修改textNode文本节点中的文本内容，当文本内容变动后，callback会自动被调用，因此输出text node data change。</li></ul> <h3 id="nexttick-实现原理"><a href="#nexttick-实现原理" class="header-anchor">#</a> nextTick 实现原理</h3> <p>将传入的回调函数包装成异步任务，异步任务又分微任务和宏任务，为了尽快执行所以优先选择微任务；
nextTick 提供了四种异步方法 Promise.then、MutationObserver、setImmediate、setTimeOut(fn,0)</p> <h3 id="源码解读"><a href="#源码解读" class="header-anchor">#</a> 源码解读</h3> <blockquote><p>源码位置 core/util/next-tick
源码并不复杂，三个函数，60几行代码，沉下心去看！
Tips:为了便于理解我调整了源码中 nextTick、timerFunc、flushCallbacks 三个函数的书写顺序</p></blockquote> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> noop <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'shared/util'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> handleError <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./error'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> isIE<span class="token punctuation">,</span> isIOS<span class="token punctuation">,</span> isNative <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./env'</span>

<span class="token comment">//  上面三行与核心代码关系不大，了解即可</span>
<span class="token comment">//  noop 表示一个无操作空函数，用作函数默认值，防止传入 undefined 导致报错</span>
<span class="token comment">//  handleError 错误处理函数</span>
<span class="token comment">//  isIE, isIOS, isNative 环境判断函数，</span>
<span class="token comment">//  isNative 判断是否原生支持，如果通过第三方实现支持也会返回 false</span>


<span class="token keyword">export</span> <span class="token keyword">let</span> isUsingMicroTask <span class="token operator">=</span> <span class="token boolean">false</span>     <span class="token comment">// nextTick 最终是否以微任务执行</span>

<span class="token keyword">const</span> callbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>     <span class="token comment">// 存放调用 nextTick 时传入的回调函数</span>
<span class="token keyword">let</span> pending <span class="token operator">=</span> <span class="token boolean">false</span>     <span class="token comment">// 标识当前是否有 nextTick 在执行，同一时间只能有一个执行</span>


<span class="token comment">// 声明 nextTick 函数，接收一个回调函数和一个执行上下文作为参数</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token parameter">cb<span class="token operator">?</span><span class="token operator">:</span> Function<span class="token punctuation">,</span> ctx<span class="token operator">?</span><span class="token operator">:</span> Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> _resolve
    <span class="token comment">// 将传入的回调函数存放到数组中，后面会遍历执行其中的回调</span>
    callbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// 对传入的回调进行 try catch 错误捕获</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token function">cb</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">handleError</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> ctx<span class="token punctuation">,</span> <span class="token string">'nextTick'</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>_resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">_resolve</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    
    <span class="token comment">// 如果当前没有在 pending 的回调，就执行 timeFunc 函数选择当前环境优先支持的异步方法</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pending<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        pending <span class="token operator">=</span> <span class="token boolean">true</span>
        <span class="token function">timerFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 如果没有传入回调，并且当前环境支持 promise，就返回一个 promise</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cb <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> Promise <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            _resolve <span class="token operator">=</span> resolve
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token comment">// 判断当前环境优先支持的异步方法，优先选择微任务</span>
<span class="token comment">// 优先级：Promise---&gt; MutationObserver---&gt; setImmediate---&gt; setTimeout</span>
<span class="token comment">// setTimeOut 最小延迟也要4ms，而 setImmediate 会在主线程执行完后立刻执行</span>
<span class="token comment">// setImmediate 在 IE10 和 node 中支持</span>

<span class="token comment">// 多次调用 nextTick 时 ,timerFunc 只会执行一次</span>

<span class="token keyword">let</span> timerFunc   
<span class="token comment">// 判断当前环境是否支持 promise</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> Promise <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isNative</span><span class="token punctuation">(</span>Promise<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 支持 promise</span>
    <span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 用 promise.then 把 flushCallbacks 函数包裹成一个异步微任务</span>
        p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>isIOS<span class="token punctuation">)</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>noop<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 标记当前 nextTick 使用的微任务</span>
    isUsingMicroTask <span class="token operator">=</span> <span class="token boolean">true</span>
    
    
    <span class="token comment">// 如果不支持 promise，就判断是否支持 MutationObserver</span>
    <span class="token comment">// 不是IE环境，并且原生支持 MutationObserver，那也是一个微任务</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isIE <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> MutationObserver <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>
    <span class="token function">isNative</span><span class="token punctuation">(</span>MutationObserver<span class="token punctuation">)</span> <span class="token operator">||</span>
    MutationObserver<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object MutationObserverConstructor]'</span>
<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> counter <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token comment">// new 一个 MutationObserver 类</span>
    <span class="token keyword">const</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MutationObserver</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span> 
    <span class="token comment">// 创建一个文本节点</span>
    <span class="token keyword">const</span> textNode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">)</span>   
    <span class="token comment">// 监听这个文本节点，当数据发生变化就执行 flushCallbacks </span>
    observer<span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span>textNode<span class="token punctuation">,</span> <span class="token punctuation">{</span> characterData<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        counter <span class="token operator">=</span> <span class="token punctuation">(</span>counter <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span>
        textNode<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span>  <span class="token comment">// 数据更新</span>
    <span class="token punctuation">}</span>
    isUsingMicroTask <span class="token operator">=</span> <span class="token boolean">true</span>    <span class="token comment">// 标记当前 nextTick 使用的微任务</span>
    
    
    <span class="token comment">// 判断当前环境是否原生支持 setImmediate</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> setImmediate <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isNative</span><span class="token punctuation">(</span>setImmediate<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token function">setImmediate</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">)</span>  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>

    <span class="token comment">// 以上三种都不支持就选择 setTimeout</span>
    <span class="token function-variable function">timerFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>flushCallbacks<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token comment">// 如果多次调用 nextTick，会依次执行上面的方法，将 nextTick 的回调放在 callbacks 数组中</span>
<span class="token comment">// 最后通过 flushCallbacks 函数遍历 callbacks 数组的拷贝并执行其中的回调</span>
<span class="token keyword">function</span> <span class="token function">flushCallbacks</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pending <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token keyword">const</span> copies <span class="token operator">=</span> callbacks<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment">// 拷贝一份</span>
    callbacks<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment">// 清空 callbacks</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> copies<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 遍历执行传入的回调</span>
        copies<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 为什么要拷贝一份 callbacks</span>

<span class="token comment">// callbacks.slice(0) 将 callbacks 拷贝出来一份，</span>
<span class="token comment">// 是因为考虑到 nextTick 回调中可能还会调用 nextTick 的情况,</span>
<span class="token comment">// 如果 nextTick 回调中又调用了一次 nextTick，则又会向 callbacks 中添加回调，</span>
<span class="token comment">// nextTick 回调中的 nextTick 应该放在下一轮执行，</span>
<span class="token comment">// 如果不将 callbacks 复制一份就可能一直循环</span>
</code></pre></div><h2 id="组件设计"><a href="#组件设计" class="header-anchor">#</a> 组件设计</h2> <h4 id="单一职责"><a href="#单一职责" class="header-anchor">#</a> 单一职责</h4> <p>你的组件是否符合<strong>只实现一个职责，并且只有一个改变状态的理由</strong>？</p> <h4 id="通用性"><a href="#通用性" class="header-anchor">#</a> 通用性</h4> <p>放弃对DOM的掌控，只提供最基础的DOM、交互逻辑，将DOM的结构转移给开发者。</p> <ul><li>存在代码重复吗？如果只使用一次，或者只是某个特定用例，可能嵌入组件中更好。</li></ul> <ul><li><p>如果它只是几行代码，分隔它反而需要更多的代码，那是否可以直接嵌入组件中？</p></li> <li><p>性能会收到影响吗？更改state/props会导致重新渲染，当发生这种情况时，你需要的是 只是重新去渲染经过diff之后得到的相关元素节点。在较大的、关联很紧密的组件中，你可能会发现状态更改会导致在不需要它的许多地方重新呈现，这时应用的性能就可能会开始受到影响。</p></li> <li><p>你是否有一个明确的理由？分离代码我想要实现什么？更松散的耦合、可以被复用等，如果回答不了这个问题，那最好先不要从组件中抽离。</p></li> <li><p>这些好处是否超过了成本？分离代码需要花费一定的时间和精力，我们要在业务中去衡量，有所取舍。</p></li></ul> <h4 id="封装"><a href="#封装" class="header-anchor">#</a> 封装</h4> <p>良好的组件封装应该<strong>隐藏内部细节和实现意义</strong>，并通过<strong>props</strong>来控制行为和输出。</p> <p><strong>减少访问全局变量</strong>：因为它们打破了封装，创造了不可预测的行为，并且使测试变得困难。可以将全局变量作为组件的props，而不是直接引用。</p> <h4 id="组合"><a href="#组合" class="header-anchor">#</a> 组合</h4> <ul><li>具有多个功能的组件，应该转换为多个小组件。</li> <li>单一责任原则描述了如何将需求拆分为组件，封装描述了如何组织这些组件，组合描述了如何将整个系统粘合在一起。</li></ul> <h4 id="纯组件和非纯组件"><a href="#纯组件和非纯组件" class="header-anchor">#</a> 纯组件和非纯组件</h4> <ul><li>非纯组件有显示的副作用，我们要尽量隔离非纯代码。</li> <li>将全局变量作为props传递给组件，而非将其注入到组件的作用域中。</li> <li>将网络请求和组件渲染分离，只将数据传递给组件，保证组件职责的单一性，也能将非纯代码从组件中隔离。</li></ul> <h4 id="可测试"><a href="#可测试" class="header-anchor">#</a> 可测试</h4> <ul><li>测试不仅仅是自动检测错误，更是检测组件的逻辑。</li> <li>如果一个组件测试不易于测试，很大可能是你的组件设计存在问题。</li></ul> <h4 id="富有意义"><a href="#富有意义" class="header-anchor">#</a> 富有意义</h4> <ul><li>开发人员大部分时间都在阅读和理解代码，而不是实际编写代码。</li> <li>有意义的函数、变量命名，可以让代码具有良好的可读性。</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vuepress/Web/code.html" class="prev">
        代码
      </a></span> <!----></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/vuepress/assets/js/app.057f928e.js" defer></script><script src="/vuepress/assets/js/3.7d3f161f.js" defer></script><script src="/vuepress/assets/js/16.493ded96.js" defer></script>
  </body>
</html>
